#! /bin/bash

# get some colors
if [[ -f $HOME/.shell_colors ]]; then
  source $HOME/.shell_colors
fi

function usage() {
  echo "Run the script as follows:"
  echo "$(basename $0) [-h] [-c country_code] [-vvv] [-l load] [-"
  exit 2
}

verbosity=0

while getopts "c:l:hv" opt; do
  case ${opt} in
    h) usage ;;
    c) country="${OPTARG}" ;;
    l) load="${OPTARG}" ;;
    v) ((verbosity++)) ;;
  esac
done

# some defaults
country=${country:-US} # default to US servers
load=${load:-40} # below 40% load

# variables used throughout
proton_path="$HOME/.cache/Proton"
serverlist="${proton_path}/VPN/serverlist.json"
proton_app_command=protonvpn-app
proton_app_config_path="$HOME/.config/Proton/VPN/app-config.json"

# var for querying the US entry/exit servers with additional params
select_this=".value.EntryCountry == \"${country}\" \
and .value.ExitCountry == \"${country}\" \
and .value.Tier >= 2 \
and .value.Load < \"${load}\" \
and .value.Status == 1"

function run_my_cmd() {
#  echo "in cmd"
  cmd="${1}"
  shift
  command_attempt=$("${cmd}" "$@")
  if [[ $? -ne 0 ]]; then
    printf "${RED}Something went wrong!...${NOCOL}\n"
    usage
    exit 1
  else
    printf "${GREEN}Success...${NOCOL}\n"
  fi
}

# general function to append to commands to invoke the run_my_cmd function
# not every kind of action can be prepended by the run_my_cmd
function check_return() {
  if [[ $? -eq 0 ]]; then
    run_my_cmd /bin/true
  else
    run_my_cmd /bin/false
  fi
}

function get_random_server() {
  # get a random index from the list of indexes
  random_server_index=${server_indexes[RANDOM % ${#server_indexes[@]}]}
  # once we have the index, get some info about it
  random_server=$(jq -r ".LogicalServers[${random_server_index}]" ${serverlist})
  random_server_name=$(jq -r ".LogicalServers[${random_server_index}].Name" ${serverlist})
}

function parse_serverlist() {
  # create an array of the server indexes, according to the search params
  mapfile -t server_indexes < <(jq -r ".LogicalServers | to_entries | map(select(${select_this})) | .[].key" "${serverlist}")

  # check if the array is populated, otherwise we should fail out at this point
  if [[ ${#server_indexes[@]} -eq 0 ]]; then
    printf "\n${RED}We didn't find any servers with this search term:\n${NOCOL}${select_this}\n\n"
    run_my_cmd /bin/false
  fi
}

function stop_protonvpn() {
  # check if protonvpn-app is running
  if [[ $(pgrep "${proton_app_command}") ]]; then

    [[ ${verbosity} -ge 1 ]] && printf "${YELLOW}  ${proton_app_command} found to be running, stopping it...${NOCOL}\n"
    # find the network manager configs in place

    [[ ${verbosity} -ge 1 ]] && printf "${YELLOW}  Finding the networking configs created by protonvpn...${NOCOL}"
    killswitch_connection=$(nmcli c s | awk '/pvpn-killswitch/{print $1}'); check_return

    [[ ${verbosity} -ge 1 ]] && printf "${YELLOW}  Stopping networking...${NOCOL}"
    nmcli networking off; check_return

    [[ ${verbosity} -ge 1 ]] && printf "${YELLOW}  Removing remnant networking configs...${NOCOL}"
    killall "${proton_app_command}"; check_return
  fi
}

function replace_autoconnect_server() {
  sed -i "s/\"connect_at_app_startup\":.*/\"connect_at_app_startup\": \"${random_server_name}\",/" ${proton_app_config_path}
}

function start_protonvpn() {
  [[ ${verbosity} -ge 1 ]] && printf "${YELLOW}  Turning networking back on...${NOCOL}"
  nmcli networking on; check_return

  [[ ${verbosity} -ge 1 ]] && printf "${YELLOW}  Starting ${proton_app_command}...${NOCOL}"
  ${proton_app_command} > /dev/null 2>&1 &
  check_return

  if [[ ! $(pgrep ${proton_app_command}) ]]; then
    run_my_cmd /bin/false
  fi
}

###################################################################################
## Below is the script runtime, calling the above functions in appropriate order ##
###################################################################################

[[ ${verbosity} -ge 2 ]] \
  && printf "${PURPLE}INFO: Using this search term:${NOCOL}\n  ${select_this}\n"

printf "${BLUE}Trying to define an array of servers...${NOCOL}"
parse_serverlist; check_return

printf "${BLUE}Getting a random server from the array...${NOCOL}"
get_random_server; check_return

[[ ${verbosity} -ge 1 ]] \
  && printf "${PURPLE}This is the server we're going to connect to:${NOCOL}\n${random_server}\n"

printf "${BLUE}Stopping ${proton_app_command}...${NOCOL}\n"
stop_protonvpn; check_return

printf "${BLUE}Replacing the server with a discovered random one...${NOCOL}\n"
replace_autoconnect_server; check_return

printf "${BLUE}Starting ${proton_app_command}...${NOCOL}\n"
start_protonvpn; check_return
